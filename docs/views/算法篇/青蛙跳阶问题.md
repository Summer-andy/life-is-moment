---
title: 青蛙跳阶
date: 2021-04-20
tags:
 - leetcode刷题
categories:
 - 前端基础
---

## 题目描述

  一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 10 级的台阶总共有多少种跳法?

## 题解思路

  - 递归    

   想要跳到第10级台阶, 我们要么从第九阶开始跳, 要么从第8阶开始跳。
   同理如果要从第8阶开始跳, 要么从第7阶开始, 要么从第6阶开始。

   因此 fn(10) = fn(9) + fn(8);

   接下来, 我们需要考虑边界情况:
   fn(2) = 2;
   fn(1) = 1;

   因此我们可以通过递归函数去解决这个问题: 

   ```js
    var jump = function(n) {
      if(n === 2) return 2;
      if(n === 1) return 1;
      return jump(n-1)+jump(n-2);
    }
   ```

   上述解法虽然简洁明了, 但是很容易出现超时的情况, 超时无非就是计算的时间过长了。在计算f10的时候会去计算f9和f8, 而在计算f9的同时会计算f8和f7, 而计算f8的时候会计算f7和f6, 很明显
   发生了重复计算。

   那么它的时间复杂度是多少呢？

   递归时间的复杂度 =  解决一个子问题的时间 * 子问题的个数。

   解决一个子问题是加法操作 因此复杂度为 1

   子问题的个数为 2^n

   因此它的复杂度为 O(2^n)。

  - 带备忘录的递归算法

    ```js
    var map = new Map();
    var jump = function(n) {
      if(n === 2) return 2;
      if(n === 1) return 1;
      if(map.get(n)) {
        return map.get(n)
      } else {
        map.set(n, jump(n-1)+jump(n-2))
        return map.get(n);
      }
    }
    ```

    经过我们的优化后, 时间复杂度为O(n)

   - 动态规划

    与备忘录不同的是, 动态规划从较小的问题开始解, 逐步决策出较大问题的解, 因此它是自底向上的。动态规划里面有几个典型的特征,

    - 最优子结构: fn(n-1) 和 fn(n-2) 称之为最优子结构
    - 状态转移方程: fn(n) = fn(n-1) + fn(n-2) 称之为状态转移方程
    - 边界: fn(1) = 1, fn(2) = 2 就是边界
    - 重叠子问题： fn(10) = fn(9) + fn(8), fn(9) = fn(8) + fn(7), 其中 fn(8) 就是重叠子问题

    ```js
    var jump = function(n) {
      if(n === 2) return 2;
      if(n === 1) return 1;
      let a = 1, b = 2, temp = 0;
      for (let i = 3; i <= n; i++) {
        temp = a + b;
        a = b;
        b = temp;
      }

      return temp;
    }
    ```

    时间复杂度还是没变, 空间复杂度从O(n) -> O(1) ~ 