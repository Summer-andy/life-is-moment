### 1.什么是作用域？
+ 1.1 编译原理: 1.分词/词法分析 2.解析/语法解析 3.代码生成 (var a = 2)
+ 1.2 理解作用域
    - 1.2.1 演员表
     首先计算机如果要对 ```  var a = 2 ``` 这句代码进行解读的话,需要有三个角色参与其中, 他们分别是: 1.引擎 2.编译器 3.作用域。他们三个各司其职: 引擎负责整个js程序的编译以及执行过程, 编译器负责负责语法解析以及代码生成, 作用域负责收集和维护所声明变量的查询以及维护,并且实施一套非常严格的规则,确定当前代码对变量的访问是否有权限
    - 1.2.2 对话  
     举例: 对于解析并且运行 ``` var a = 2 ```这句代码。他们三个角色,分别做了什么？首先编译器会把这些字符串分别为单个词语,然后进行解析生成一颗语法树。首先编译器会先去询问作用域是否已经有同一个变量存在于当前作用域中,如果是作用域会忽略此次声明,继续编译。否则他会要求作用域声明一个变量a.接下来引擎会为编译器生成引擎所需要的代码。这些代码用于处理 a = 2这个赋值操作。引擎运行时会询问当前作用域是否存在变量a,如果是那么就引用该变量,如果不是那么引擎就询问上次作用域。如果一直没有找到,那么引擎就会举手示意抛出一个异常。总结: 编译器与引擎在这段对话中,最大的区别就是,编译器可以要求作用域给他干任何事情。但是引擎只能询问作用域有无引擎想要的,如果没有那么会举手报错。
    - 1.2.3 深入了解编译器
    当引擎执行上述代码的时候, 引擎干的事情主要是查询功能。在上述例子中,引擎会为变量a进行LHS(赋值的操作目标是谁)。当然还有RHS(赋值操作的源头)。比如 var a = 2;就是LHS。 console.log(a)就是RHS。

### 2.词法作用域?
+ 1.1 词法作用域意味着作用域是由书写代码时函数声明的位置来决定的
+ 1.2 js 中有两个机制可以“欺骗”词法作用域:eval(..) 和 with。前者可以对一段包 含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域(在 运行时)。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域(同样是在运行时).这二个机制的副作用是引擎无法在编译时查找进行优化。使用这二个机制都会让代码运行变慢,所以不要使用他们。

### 3.函数作用域和块作用域？